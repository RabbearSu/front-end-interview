### 贝叶斯公式 
后验概率

### 盒子模型：
标准盒子模型：盒子的总宽度 =  margin + border + padding + content （content =  width | height）
IE盒子模型：盒子的总宽度 = margin + content （content = border + padding + width | height）

### 脱离文档流
position: relative 不行

### 石子问题
两个人，A和B，两堆石子个数为8和9。每人每次可以从其中一堆取走1或2或3个石子。谁先把石子全部取完谁获胜，为A指定策略。

因为每次可以取1/2/3个，所以一轮下来两人一共可以取4个。不管B取多少个，A可以让一轮下来石子的个数少4，这样只要剩余石子是4的倍数，A就必胜。所以一开始A取1个即可。

### SQL查询
%: 模糊查询

### 页面调度算法
**OPT**：最佳置换算法。置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。

**FIFO**：先进先出。优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。
FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为**Belady异常**。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。

**LRU**：最近最久未使用。选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。

**CLOCK**：时钟置换算法。简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。
CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：
1. 最近未被访问，也未被修改(u=0, m=0)。
2. 最近被访问，但未被修改(u=1, m=0)。
3. 最近未被访问，但被修改(u=0, m=1)。
4. 最近被访问，被修改(u=1, m=1)。

算法执行如下操作步骤：
1. 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。
2. 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。
3. 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。

### JS代码结果
```javascript
(function() {
      var a = b = 5;
  })();   
console.log(b);
console.log(a);
```
输出结果为5和报错。 `var a=b=5`等价于`var a=b; b=5`，这里b是全局变量，a是局部变量。

### HTML5新的表单元素
- datalist: 规定输入域的选项列表，通过option创建
- keygen: 提供一种验证用户的可靠方法，密钥对生成器
- output: 元素用于不同类型的输出

### 置换元素
**置换元素**：浏览器根据元素的标签和属性，来决定元素的具体显示内容。 
例如：浏览器会根据\<img>标签的src属性的 值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；\<input>标签的type属性来决定是显示输入框，还是单选按钮等。html中的\<img>、\<input>、\<textarea>、\<select>、\<object> 都是置换元素。这些元素往往没有实际的内容，即是一个空元素。
置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。

**不可替换元素**：html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。
例如： \<label>label中的内容\</label> 标签\<label>是一个非置换元素，文字label中的内容”将全被显示。

### 回流和重绘
repaint(重绘)：元素的外观被改变，且在没有改变布局的情况下发生，如改变outline,visibility,background color，不会影响到dom结构渲染。

reflow(回流)：与repaint区别就是他会影响到dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素(祖先)，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。

display:none会产生reflow

visibility:hidden只会repaint

### HTTP
- http的协议是TCP
- https的端口是443
- 传输层提供端到端的可靠报文传递和错误恢复

### 进程与线程
进程是资源分配的最小单位，线程是CPU调度的最小单位。
以工厂举例：cup -> 工厂，车间 -> 进程，线程 -> 工人

### 排序算法
- 不稳定：快选堆希
- 稳　定：插冒归基

稳定性排序的好处：对于结构体元素，想在排序的同时不改变其他元素的次序。比如：
```json
person = {
  "name":"jack",
  "age": 18,
  "height": 170
}
```
对年龄排序时保证身高的原有次序不改变，就必须使用稳定排序。

### 表单元素的禁用
- document.getElementById("btn").disabled = true;
- document.getElementById("btn").setAttribute("disabled","true");

均可。注意：因为disabled属性是布尔值，所以用setAttribute设置属性时，会将第二个参数"true"转换为布尔值。
**setAttribute**的第二个参数不论是什么都会转换为string类型，也就是说不管是"null","true","false"都会生效。

### 编程题
1.你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任意一张 CD 内的歌数不能被 13 这个数字整除，那么请问你出这张专辑至少需要多少张 CD ？
```javascript
// n:歌曲数 s:每首歌的时间 L:一张CD的总时间容量
function getCDNum(n, s, L) {
    var max = Math.floor((L + 1) / (s + 1)) //一张CD最多可以放多少首歌
    max = max % 13 === 0 ? max - 1 : max //如果被13整除则少1
    var num = Math.ceil(n / max) //正常情况下需要多少张CD

    //情况1 一张都没有放满且被13整除
    //情况2 最后一张被13整除且(max-1)也被13整除(不能从上一张拿一首歌到最后一张CD)
    //情况3 没有被13整除的情况发生
    if (n < max && n % 13 === 0) {
        console.log(2)
        return
    }
    if ((n - (num - 1) * max) % 13 === 0 && (max - 1) % 13 === 0 ){
        console.log(num + 1)
        return
    }
    console.log(num)
    return
}
getCDNum(7,2,6) //4
```

2.现在有一个字符串，你要对这个字符串进行 n 次操作，每次操作给出两个数字：(p, l) 表示当前字符串中从下标为 p 的字符开始的长度为 l 的一个子串。你要将这个子串左右翻转后插在这个子串原来位置的正后方，求最后得到的字符串是什么。字符串的下标是从 0 开始的，你可以从样例中得到更多信息。
输入
>ab
2
0 2
1 3

输出
>abbaabb

```javascript
function getString(str, n) {
    var old = str
    for (var i = 0; i < n; i++) {
        var start = parseInt(arguments[i + 2].split(' ')[0])
        var len = parseInt(arguments[i + 2].split(' ')[1])
        str += str.substr(start, len).split('').reverse().join('')
    }
    console.log('输入是:' + old)
    console.log('输出是:' + str)
    return
}

getString('ab', 2, '0 2', '1 3') //abbaabb
```